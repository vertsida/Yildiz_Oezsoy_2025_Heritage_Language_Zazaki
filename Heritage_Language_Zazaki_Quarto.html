<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ali Yıldız">
<meta name="dcterms.date" content="2025-08-13">
<meta name="keywords" content="heritagea language, multilingualism, bilingualism, german, turkish, zazaki, zaza language">

<title>Transmission of Zazaki as a Heritage Language: Germany and Turkey</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Heritage_Language_Zazaki_Quarto_files/libs/clipboard/clipboard.min.js"></script>
<script src="Heritage_Language_Zazaki_Quarto_files/libs/quarto-html/quarto.js"></script>
<script src="Heritage_Language_Zazaki_Quarto_files/libs/quarto-html/popper.min.js"></script>
<script src="Heritage_Language_Zazaki_Quarto_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Heritage_Language_Zazaki_Quarto_files/libs/quarto-html/anchor.min.js"></script>
<link href="Heritage_Language_Zazaki_Quarto_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Heritage_Language_Zazaki_Quarto_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Heritage_Language_Zazaki_Quarto_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Heritage_Language_Zazaki_Quarto_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Heritage_Language_Zazaki_Quarto_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Transmission of Zazaki as a Heritage Language: Germany and Turkey</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Ali Yıldız <a href="mailto:ayildiz8@smail.uni-koeln.de" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            University of Cologne, Institute of Linguistics
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 13, 2025</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>The characteristic theme of the works of Stone is the bridge between culture and society. …</p>
  </div>
</div>

<div>
  <div class="keywords">
    <div class="block-title">Keywords</div>
    <p>heritagea language, multilingualism, bilingualism, german, turkish, zazaki, zaza language</p>
  </div>
</div>

</header>


<p>CITED = Formatting Required CITE = Add Appropriate Citation</p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In multilingualism research there is a growing emphasis on the fact that multilinguals are not a homogenous group regarding the high individual variation, and the need for involving more factors into play. A subgroup in this regard of multilinguals, which has been gaining scholarly interest (<span class="citation" data-cites="fridman_oezsoy_sentiments_2024">@fridman_oezsoy_sentiments_2024</span>) are heritage speakers (Polinsky 2011 CITED).</p>
<p>Polinsky (2015 CITED) defines heritage language speakers as individuals who grow up in families where a language other than the dominant language of the surrounding society is spoken at home. This heritage language is usually acquired in early childhood through natural, informal communication with family members, often as the first language or alongside the community’s majority language. However, because schooling, peers, and wider society predominantly use the majority language, many heritage speakers gradually become more proficient in that language, which becomes dominant in adulthood. As a result, they often develop an imbalanced bilingualism, characterized by greater receptive skills (listening and understanding) than productive skills (speaking, reading, and writing) in the heritage language. While they may retain native-like pronunciation and familiarity with everyday vocabulary, they frequently show gaps in grammar, literacy, and formal registers. Heritage speakers vary widely along a continuum, some are nearly balanced bilinguals, while others understand their heritage language well but speak it only rarely.</p>
<p>The differention of heritage language speakers from other multilinguals has been various. The weak definition refers to individuals who are born in majority language environment different than the language spoken at home [CITE]. Other research adds additional criteria, such as moving age, acquisition of heritage language, extensive or formal education in formal language, or living in a place where heritage language is the societal language [CITE]. Unlike other multilingual groups, such as second language learners, heritage speakers display ____, __<em>,</em> [CITE].</p>
<p>Research on heritage langauge has been diverse, focusing on different areas. Social [CITE] and cognitive [CITE] aspects have been individually well-studied, however a combining bridge has to our existence remained limited, with exceptions of [CITE], [CITE]. To address this research gap, this study aims at building up a connection using a cultural vocabulary test and inhibition.</p>
<section id="cultural-vocabulary" class="level2">
<h2 class="anchored" data-anchor-id="cultural-vocabulary">(Cultural) Vocabulary</h2>
<p>Cultural vocabulary is shows that different diasporic contexts can meaningfully influence heritage language maintenance and that culture-specific vocabulary tends to be more resilient than neutral or basic vocabulary. Beyond the domain-specific cognitive capacity of language, we also examine the relationship between heritage language maintenance and the domain-general capacity of inhibitory control. Shan (2024) is the first to assess inhibitory control in heritage speakers using the Stroop task, revealing correlations between cognitive control and heritage language experience.</p>
</section>
<section id="inhibition-in-heritage-language-speakers" class="level2">
<h2 class="anchored" data-anchor-id="inhibition-in-heritage-language-speakers">Inhibition in Heritage Language Speakers</h2>
</section>
<section id="zazaki-as-a-heritage-language" class="level2">
<h2 class="anchored" data-anchor-id="zazaki-as-a-heritage-language">Zazaki as a Heritage Language</h2>
<p>As noted earlier, many research on heritage langauges focused on well-studied languages such as Spanish in US or Turkish in Germany. Other varieties have remained underexplored, and in order to address this gap, this research targets Zazaki. Being a northwestern Iranian language spoken primarily in eastern turkey and metropols such as Istanbul Ankara Izmir and Mersin, Zazaki has worldwide around 4-6 million speakers.</p>
</section>
</section>
<section id="methodology" class="level1">
<h1>Methodology</h1>
<section id="participants" class="level2">
<h2 class="anchored" data-anchor-id="participants">Participants</h2>
<p>There are XX participants in this study (n=XX) forming two main groups: a) speakers from Turkey who speak Turkish as dominant &amp; majority language and b) speakers speaking German as dominant &amp; majority language.</p>
<p>The first group origin from Dersim, where xxx dialect of Zazaki is spoken [CITE]. [Put Metadata Here] The second group on the other hand is diverse and drives speakers from various cities, such as Bingöl and Diyarbakir, incorporating diferent dialects of Zaza is spoken [CITE]. It must be noted that a great number of Zaza heritage speakers in Germany are both fluent speakers in Turkish and Zazaki, as monolingual policies that targeted erasure of Zaza precedes so called guest worker migration to Germany, which leaded a Turkish as lingua franca in between guest workers coming from Turkey in the region, forming a group dominant language [CITE].</p>
</section>
<section id="procedure" class="level2">
<h2 class="anchored" data-anchor-id="procedure">Procedure</h2>
<p>To address our research questions, we developed a web-based experiment using PCIbex (Zehr &amp; Schwarz, 2018). Participants completed three tasks: a vocabulary translation task with heritage language vocabulary, a Stroop task (in the dominant language: German, English, or Turkish), and an adapted version of the HeLEx questionnaire (Tomić et al., 2023).</p>
<section id="cultural-vocabulary-task" class="level3">
<h3 class="anchored" data-anchor-id="cultural-vocabulary-task">(Cultural) Vocabulary Task</h3>
<p>In the task, 20 randomly selected, corpus-driven vocabulary items were presented in a random order. Unlike Shabtaev’s (2024) study, where participants completed a yes/no picture-naming task to indicate whether they knew the item, our study asked participants to translate or describe the given vocabulary item. This approach was chosen to minimize the possibility of random guessing. The stimuli were designed to cover a range of semantic areas and frequency levels, so as not to overrepresent a single semantic field and to include words of varying frequencies. Loanwords from Turkish were excluded to avoid potential linguistic transfer or interference effects. Given that Zazaca is spoken with considerable variation, some words were presented with possible dialectal differences, for example, <em>zaf</em> or <em>zof</em> (‘very’), and participants were asked to provide only one variant of the item.</p>
</section>
<section id="stroop-task" class="level3">
<h3 class="anchored" data-anchor-id="stroop-task">Stroop Task</h3>
<p>After the vocabulary task, participants completed a Stroop task. The task involved four colors: blue, green, red, and yellow. Participants were instructed to press the <strong>F</strong> key for congruent stimuli and the <strong>J</strong> key for incongruent stimuli. To minimize distraction effects in the initial responses, a practice round of 10 words was administered first. Each trial began with a fixation cross (+) displayed at the stimulus location for 300 ms to help participants focus. The stimulus was then shown for 2000 ms, after which feedback (“correct” or “incorrect”) was displayed for 500 ms. Responses made after 2000 ms were considered incorrect. All text in this task was presented in a substantially larger font to improve accessibility for participants with visual impairments.</p>
</section>
<section id="heritage-language-questionnaire-helex" class="level3">
<h3 class="anchored" data-anchor-id="heritage-language-questionnaire-helex">Heritage Language Questionnaire (HeLEx)</h3>
</section>
</section>
</section>
<section id="data-processing-analysis" class="level1">
<h1>Data Processing &amp; Analysis</h1>
<section id="bayesian-statistics" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-statistics">Bayesian Statistics</h2>
</section>
</section>
<section id="results" class="level1">
<h1>Results</h1>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
</section>
<section id="data-availability-statement" class="level1">
<h1>Data Availability Statement</h1>
<p><strong>[UPDATE]</strong> The experimental materials, analyses and data that supports the findings of this study are openly available via the Open Science Framework at the following link:</p>
</section>
<section id="competing-interests" class="level1">
<h1>Competing Interests</h1>
<p><strong>[UPDATE]</strong> The author identifies as Zaza, which is also the focus of this research. This connection is disclosed in the interest of transparency. The author declares no competing interests.</p>
</section>
<section id="publishing-ethics" class="level1">
<h1>Publishing Ethics</h1>
<p><strong>[UPDATE]</strong> The authors assert that all procedures contributing to this work comply with the ethical standards of the relevant national and institutional committees on human experimentation and with the Helsinki Declaration of 1975, as revised in 2008. The current study was approved by the ethics committee of the University of Cologne (application XX / 2025)</p>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>